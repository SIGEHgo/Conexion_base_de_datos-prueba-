host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
print("is valid")
print(DBI::dbIsValid(buig))
ui <- fluidPage(
titlePanel("Explorador de Base de Datos BUIG"),
fluidRow(
column(
width = 4,
selectInput("tabla", "Selecciona una tabla:", choices = Lista_BUIG),
verbatimTextOutput("estado_conexion"),
actionButton("reconectar", "Reconectar DB")
),
column(
width = 8,
DTOutput("vista_tabla")
)
)
)
library(shiny)
library(DBI)
library(RPostgres)
library(DT)
ui <- fluidPage(
titlePanel("Explorador de Base de Datos BUIG"),
fluidRow(
column(
width = 4,
selectInput("tabla", "Selecciona una tabla:", choices = Lista_BUIG),
verbatimTextOutput("estado_conexion"),
actionButton("reconectar", "Reconectar DB")
),
column(
width = 8,
DTOutput("vista_tabla")
)
)
)
# ---- Servidor ----
server <- function(input, output, session) {
# Estado reactivo de conexión
conexion_valida <- reactivePoll(2000, session,
checkFunc = function() DBI::dbIsValid(buig),
valueFunc = function() DBI::dbIsValid(buig)
)
# Mostrar estado de conexión
output$estado_conexion <- renderText({
if (conexion_valida()) {
paste("🟢 Conexión activa con", db_name)
} else {
"🔴 Conexión perdida"
}
})
# Botón para reconectar
observeEvent(input$reconectar, {
try({
buig <<- DBI::dbConnect(
RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
showNotification("Conexión restablecida correctamente.", type = "message")
}, silent = TRUE)
})
# Mostrar tabla seleccionada
output$vista_tabla <- renderDT({
req(input$tabla)
if (!DBI::dbIsValid(buig)) {
return(DT::datatable(data.frame(Error = "Conexión no válida")))
}
datos <- tryCatch(DBI::dbReadTable(buig, input$tabla), error = function(e) NULL)
if (is.null(datos)) {
DT::datatable(data.frame(Error = paste("No se pudo leer la tabla:", input$tabla)))
} else {
DT::datatable(datos, options = list(pageLength = 10))
}
})
}
# ---- Lanzar App ----
shinyApp(ui, server)
ui <- fluidPage(
fluidRow(
column(
width = 4,
selectInput("tabla", "Selecciona una tabla:", choices = Lista_BUIG),
verbatimTextOutput("estado_conexion"),
actionButton("reconectar", "Reconectar DB")
),
column(
width = 8,
DTOutput("vista_tabla")
)
)
)
server <- function(input, output, session) {
# Estado de conexión
conexion_valida = reactivePoll(2000, session,
checkFunc = function() DBI::dbIsValid(buig),
valueFunc = function() DBI::dbIsValid(buig)
)
output$estado_conexion = renderText({
if (conexion_valida()) {
paste("🟢 Conexión activa con", db_name)
} else {
"🔴 Conexión perdida"
}
})
# Botón para reconectar
observeEvent(input$reconectar, {
try({
buig <<- DBI::dbConnect(
RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
showNotification("Conexión restablecida correctamente.", type = "message")
}, silent = TRUE)
})
# Tabla
output$vista_tabla = renderDT({
req(input$tabla)
if (!DBI::dbIsValid(buig)) {
return(DT::datatable(data.frame(Error = "Conexión no válida")))
}
datos = DBI::dbReadTable(buig, input$tabla)
if (is.null(datos)) {
DT::datatable(data.frame(Error = paste("No se pudo leer la tabla:", input$tabla)))
} else {
DT::datatable(datos, options = list(pageLength = 10))
}
})
}
# ---- Lanzar App ----
shinyApp(ui, server)
source("~/.active-rstudio-document", echo = TRUE)
rsconnect::writeManifest()
library(shiny)
library(DBI)
library(RPostgres)
library(DT)
library(leaflet)
runApp()
db_host = 'sigmapdb.csedvatdfhkw.us-west-2.rds.amazonaws.com'
db_user = 'geo_citnova'
db_pass = "Password2025"
db_port = 5432
db_name = 'geo_citnova'
runApp()
runApp()
runApp()
runApp()
runApp()
datos = datos|> dplyr::slice_head(n = 20) |> dplyr::collect() |>
dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
runApp()
output$mapa <- renderLeaflet({
leaflet() |>
addTiles() |>
setView(0.34580993652344, 50.6252978589571, zoom = 3)
})
##Codigo para conectarnos a sql usando dplyr
buig <- DBI::dbConnect(
RPostgres::Postgres(),
dbname=db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
ui <- fluidPage(
fluidRow(
column(
width = 4,
selectInput(inputId = "tabla", label =  "Selecciona una tabla:", choices = Lista_BUIG),
verbatimTextOutput("estado_conexion"),
actionButton(inputId = "reconectar", label = "Reconectar DB")
),
column(
width = 8,
DTOutput("vista_tabla"),
leafletOutput("mapa")
)
)
)
server <- function(input, output, session) {
# Botón para reconectar
observeEvent(input$reconectar, {
try({
buig <<- DBI::dbConnect(
RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
showNotification("Conexión restablecida correctamente.", type = "message")
}, silent = TRUE)
})
# Tabla
output$vista_tabla = renderDT({
req(input$tabla)
if (!DBI::dbIsValid(buig)) {
return(DT::datatable(data.frame(Error = "Conexión no válida")))
}
datos = DBI::dbReadTable(buig, input$tabla)
datos = datos|> dplyr::slice_head(n = 20) |> dplyr::collect() |>
dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
cat("Vamos imprimir datos")
print(datos)
coordenadas = sf::st_coordinates(datos$geom[1])[1,1]
if (coordenadas > 30) {
datos = datos |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
datos = datos |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
if (is.null(datos)) {
DT::datatable(data.frame(Error = paste("No se pudo leer la tabla:", input$tabla)))
} else {
DT::datatable(datos, options = list(pageLength = 10))
}
})
output$mapa <- renderLeaflet({
leaflet() |>
addTiles() |>
setView(0.34580993652344, 50.6252978589571, zoom = 3)
})
}
shinyApp(ui, server)
runApp()
runApp()
rsconnect::writeManifest()
runApp()
source("~/.active-rstudio-document", echo = TRUE)
runApp()
source("~/.active-rstudio-document", echo = TRUE)
runApp()
runApp()
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
runApp()
runApp()
runApp()
install.packages("pool")
##Codigo para conectarnos a sql usando dplyr
buig <- pool::dbPool(
drv = RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
onStop(function() {
poolClose(buig)
})
onStop(function() {
poolClose(buig)
})
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
source("~/.active-rstudio-document", echo = TRUE)
##Codigo para conectarnos a sql usando dplyr
buig <- pool::dbPool(
drv = RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
onStop(function() {
poolClose(buig)
})
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
runApp()
library(pool)
runApp()
install.packages("pool")
library(pool)
shiny::runApp()
Lista_BUIG= pool::dbListTables(buig) |> as.list()
##Codigo para conectarnos a sql usando dplyr
buig <- pool::dbPool(
drv = RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
onStop(function() {
pool::poolClose(buig)
})
Lista_BUIG= pool::dbListTables(buig) |> as.list()
ui <- fluidPage(
fluidRow(
column(
width = 4,
selectInput(inputId = "tabla", label =  "Selecciona una tabla:", choices = Lista_BUIG),
verbatimTextOutput("estado_conexion"),
actionButton(inputId = "reconectar", label = "Reconectar DB")
),
column(
width = 8,
DTOutput("vista_tabla"),
leafletOutput("mapa")
)
)
)
server <- function(input, output, session) {
# Botón para reconectar
observeEvent(input$reconectar, {
pool::poolClose(buig)
try({
buig <<- pool::dbPool(
drv = RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
showNotification("Conexión restablecida correctamente.", type = "message")
}, silent = TRUE)
})
# Tabla
datos_reactivos <- reactive({
req(input$tabla)
if (pool::poolClosed(buig)) {
return(NULL)
}
input$tabla
#datos = DBI::dbReadTable(buig, input$tabla)
datos = DBI::dbReadTable(buig, input$tabla)  |>
dplyr::slice_head(n = 20) |>
dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
cat("Vamos imprimir datos\n")
print(datos)
coordenadas = sf::st_coordinates(datos$geom[1])[1, 1]
if (coordenadas > 30) {
datos = datos |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
datos = datos |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
return(datos)
})
output$vista_tabla <- renderDT({
datos = datos_reactivos()
if (is.null(datos)) {
DT::datatable(data.frame(Error = paste("No se pudo leer la tabla:", input$tabla)))
} else {
DT::datatable(datos, options = list(pageLength = 10))
}
})
output$mapa <- renderLeaflet({
datos = datos_reactivos()
leaflet() |>
addTiles() |>
addMarkers(data = datos)
})
session$onSessionEnded(function() {
if (!pool::poolClosed(buig)) {
pool::poolClose(buig)
message("Conexión a PostgreSQL cerrada exitosamente.")
}
})
}
shinyApp(ui, server)
library(pool)
##Codigo para conectarnos a sql usando dplyr
buig <- pool::dbPool(
drv = RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
onStop(function() {
pool::poolClose(buig)
})
Lista_BUIG= pool::dbListTables(buig) |> as.list()
ui <- fluidPage(
fluidRow(
column(
width = 4,
selectInput(inputId = "tabla", label =  "Selecciona una tabla:", choices = Lista_BUIG),
verbatimTextOutput("estado_conexion"),
actionButton(inputId = "reconectar", label = "Reconectar DB")
),
column(
width = 8,
DTOutput("vista_tabla"),
leafletOutput("mapa")
)
)
)
server <- function(input, output, session) {
# Botón para reconectar
observeEvent(input$reconectar, {
pool::poolClose(buig)
try({
buig <<- pool::dbPool(
drv = RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
showNotification("Conexión restablecida correctamente.", type = "message")
}, silent = TRUE)
})
# Tabla
datos_reactivos <- reactive({
req(input$tabla)
if (pool::poolClosed(buig)) {
return(NULL)
}
input$tabla
#datos = DBI::dbReadTable(buig, input$tabla)
datos = DBI::dbReadTable(buig, input$tabla)  |>
dplyr::slice_head(n = 20) |>
dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
cat("Vamos imprimir datos\n")
print(datos)
coordenadas = sf::st_coordinates(datos$geom[1])[1, 1]
if (coordenadas > 30) {
datos = datos |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
datos = datos |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
return(datos)
})
output$vista_tabla <- renderDT({
datos = datos_reactivos()
if (is.null(datos)) {
DT::datatable(data.frame(Error = paste("No se pudo leer la tabla:", input$tabla)))
} else {
DT::datatable(datos, options = list(pageLength = 10))
}
})
output$mapa <- renderLeaflet({
datos = datos_reactivos()
leaflet() |>
addTiles() |>
addMarkers(data = datos)
})
session$onSessionEnded(function() {
if (!pool::poolClosed(buig)) {
pool::poolClose(buig)
message("Conexión a PostgreSQL cerrada exitosamente.")
}
})
}
shinyApp(ui, server)
shiny::runApp()
runApp()
runApp()
runApp()
##Codigo para conectarnos a sql usando dplyr
buig <- pool::dbPool(
drv = RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
onStop(function() {
pool::poolClose(buig)
})
Lista_BUIG= pool::dbListTables(buig) |> as.list()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
rlang::last_trace()
runApp()
runApp()
runApp()
runApp()
source("~/.active-rstudio-document", echo = TRUE)
runApp()
runApp()
runApp()
source("~/.active-rstudio-document", echo = TRUE)
install.packages("RMySQL")
runApp()
source("~/.active-rstudio-document", echo = TRUE)
pool <- dbPool(
drv = RMySQL::MySQL(),
dbname = "shinydemo",
host = "shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com",
username = "guest",
password = "guest"
)
